[ String 클래스 ]

 ○ String 클래스는 내부 문자열 데이터에 대한 수정이 불가능하다.
	(즉, 내용 불변 : Immutable)
	문자열의 내용이 변경되면 새로운 객체를 생성하며, 참조 대상을 잃어버린 객체는 가비지 컬렉션의 대상이 되고,
	새로운 객체에 새 주소를 할당하게 되므로 해시코드도 변하게 된다.

 ○ String 클래스 간에 + 연산자를 사용하게 되면 문자열 간의 결합이 가능하며,
	String 클래스와 다른 클래스의 객체, 또는 기본형 데이터 간에 + 연산자를 사용하는 경우에도
	내부적으로 자동 String 클래스로 변환이 가능하다.
	
	※  눈으로(시각적으로, 표면적으로) 확인되는 결과는 이렇지만 	String은 내용을 변경할 수 없기 때문에
		『+』 연산자를 사용하게 되면 내부적으로 StringBuffer를 생성하여 append() 메소드를 이용해 문자열에 대한 결합을 수행하게 된다.
		따라서, 동적인 문자열을 많이 사용하는 Servlet 등에서는 되도록이면 String을 사용하는 것보다 StringBuffer나 char[] 를 사용하는 것이 효율적일 수 있다.
		
		==> 정적인 문자열을 처리하는 경우에는 주로 String 클래스를 사용 
        동적인 문자열을 처리하는 경우에는 런 타임 시 동적으로 처리해주는 StringBuffer 클래스를 사용하는 것이 효율적일 수 있다.

○ String 객체의 생성 및 특징

	String 객체를 생성하는 방법은
  ① 문자열 상수를 지정하는 방법과
	② String 클래스의 생성자를 이용하는 방법
	이렇게 두 가지 방법이 있다.
	
	String str1 = "Java";
	String str2 = "Java";
	
	String str3 = new String("Java");
	String str4 = new String("Java");
	
	하지만 『문자열 상수』를 대입 연산자를 사용하여 지정하는 방법을 통해 객체를 생성하는 경우와
	『new』 연산자를 이용하여 생성자를 통해 객체를 생성하는 것은 내부적으로 의미가 다르다.

 ※  str1, str2 객체가 참조하는 문자열 상수가 동일한 경우
     문자열이 저장된 기억 장소의 영역이 동일하기 때문에 각 객체는 동일한 기억 장소를 참조하게 된다.
     하지만 str3과 str4는 동일한 영역이 아닌 다른 기억 공간을 새롭게(→ 『new』) 확보하여 문자열 상수를 그 공간에 대입한 경우이므로 두 인스턴스는 같은 영역을 참조하는 것이 아니다.
	   따라서 『str3 == str4』는 거짓이 되며만약, 같은 문자열 상수인지의 여부를 비교해야 할 상황이라면 『equals()』 메소드를 이용해야 한다.
    → String에서의 equals()은 Object 클래스가 가지고 있는 equals()를 상속받아 메소드 오버라이딩을 통해 본래의 기능인 주소값 비교가 아닌 문자열 상수 비교를 하게된다.

  # 문자열.substring(n,m): 문자열의 인덱스번호 n번째부터 m-1번째까지 추출하여 결과 문자열을 반환하는 메소드
    문자열.substring(n): 문자열을 대상으로 n번째에서 끝까지 추출하여 결과 문자열 반환(즉, 문자열이 가진 길이 만큼)
  # 문자열.equals("문자열"): 문자열의 데이터(값)을 비교하는 메소드(true, false 반환) 대소문자 엄격히 구분함
  # 문자열.equalsIgnoreCase("문자열"): 문자열의 데이터(값)을 비교하는 메소드(true, false 반환) 대소문자 구분하지 않음
  # 문자열.indexOf("문자열"): 찾고자 하는 대상 문자열에 매개변수로 넘겨 받은 문자열이 존재한다면 그 위치를 반환하는 메소드
                             찾고자 하는 대상 문자열에 매개변수로 넘겨 받은 문자열이 존재하지 않는다면 음수를 반환하게 됨(-1)
                             해당 문자열이 여러군데 있으면 먼저 찾은 문자열의 인덱스를 반환하고 종료되는 형태
  # 문자열.lastIndexOf("문자열"): 찾고자 하는 대상 문자열에 매개변수로 넘겨 받은 문자열이 존재한다면 그 위치를 뒤에서부터 검사해서 반환하는 메소드
  # 문자열.endsWith("문자열"): 대상 문자열이 매개변수로 넘겨 받은 문자열로 끝나는지 여부를 확인하는 메소드(true, false 반환)
  # 문자열.charAt(n): 대상 문자열 중 n번째 인덱스 위치의 문자를 반환하는 메소드
  # 문자열.compareTo("문자열"): 대상문자열과 비교문자열 중 어떤 문자열이 더 큰지 비교하는 메소드
                                두 문자열이 다르다면 차이를 반환함(사전식 배열) c와 k를 비교한다면 c ~ k차이 8을 반환
                                두 문자열이 같아면 0을 반환
  # 문자열.replaceAll("기존문자열", "바꿀문자열"): 기존문자열을 찾아 바꿀문자열로 바꿔서 반환하는 메소드  JDK 1.5이후부터 사용 가능
    문자열.replaceAll("\\s",""): 공백 제거
  # 문자열.trim(): 양쪽 가장자리 공백을 제거하는 메소드
  # 문자열.split("구분자"): 구분자를 기분으로 문자열을 잘라서 문자열 배열에 담아 반환하는 메소드
  # Integer.parseInt("10"): 숫자 형태로 생긴 문자열을 정수로 변환해주는 메소드
  # Integer.toString(10): 숫자를 문자열로 변환해주는 메소드



○  StringBuffer 클래스
	
	문자열을 처리하는 클래스로 String 클래스와의 차이점은 String클래스는 내부 문자열 데이터의 수정이 불가능하지만
	StringBuffer 클래스는 문자열을 사용할 때 내부 문자열을 실행 단계에서 변경할 수 있다.
	
	즉, StringBuffer 객체는 가변적인 길이를 가지므로 객체를 생성하는 시점에서 미리 그 크기나 값을 지정하거나
	실행 시점에(런타임) 버퍼의 크기를 바꿀 수 있는 기능을 제공한다.
	
	또한, JDK 1.5이후부터는 문자열을 처리하는 StringBuilder라는 클래스도 제공한다.
	StringBuilder 클래스의 기능은 StringBuffer 클래스와 동일하지만 가장 큰 차이점은 multi-thread unsafe라는 점이다.
	즉, Syncronization이 없기 때문에 StringBuffer보다 빠르며, 동시성(동기화) 문제가 없다면 StringBuilder를 사용하는 것이 성능을 향상시킬 수 있다.
 
  # 문자열.capacity(): 문자열의 버퍼 크기를 확인하는 메소드
  # 문자열.trimToSize(): 현재 문자열을 담아들 수 있는 버퍼의 크기로 줄여주는 메소드
  # 문자열.toUpperCase(): 영문 소문자를 대문자로 변환해주는 메소드
  # 문자열.toLowerCase(): 영문 대문자를 소문자로 변환해주는 메소드
  # 문자열.insert(n,"문자열"): 대상 문자열의 n번째 인덱스에 매개변수로 넘겨 받은 문자열을 삽입해주는 메소드
  # 문자열.length(): 문자열의 길이를 반환하는 메소드
  # 문자열.delete(n,m): 인덱스번호n부터 m-1까지 대상 문자열을 삭제하는 메소드


○ StringTokenizer 클래스

	문자열 파싱(parsing)을 위한 정보를 제공하는 클래스로 파싱(parsing)하고자하는 문자열을 인자로 받아 생성하는데,
	여기서 파싱(parsing)이란 하나의 문자열을 여러 문자열로 	나누는 작업을 의미하게 되며, 
	이 때 나누는 단위가 되는 문자열을 토큰(token)이라고 한다.
	
	StringTokenizer 클래스를 사용하기 위해서는 java.util 패키지의 StringTokenizer를 import해야 한다.
	
	StringTokenizer 클래스는 호환성을 유지하는 목적으로 보관 유지되고 있으며, 문자열을 파싱하기 위해서는 String 클래스의 split()메소드나 java.util.regex 패키지를 사용할 것을 권장하고 있다.
	
○ 생성자

	-  원형
		StringTokenizer(String str)
		StringTokenizer(String str, String delim)
		StringTokenizer(String str, String delim, boolean returnDelims)
		: 주어진 문자열을 str을 단어로 분리하는 객체를 생성하며 공백(구분) 문자는 delim에 포함된 문자로 처리하게 된다.
		만약 returnDelims가 true이면 구분 문자도 분리된 데이터에 포함하여 처리하게 된다.
  # StringTokenizer의 『countTokens()』
	 int countTokens(): 파싱된 문자열의 갯수를 반환(리턴)한다.
  #	『hasMoreTokens()』
	 : 사용할 수 있는 토큰이 남아있는 경우 true를 반환
		더 이상 사용할 토큰이 없는 경우 false를 반환
		확인한 결과만 반환할 뿐 실제 데이터를 읽어들이지도 않고 실제 데이터를 읽어들이는 헤드를 이동시키지도 않는다.
  # 『nextToken()』
	: 다음 토큰을 얻어온다. 다음 토큰을 얻어오며 헤드를 이동시키게 된다.
	  구분자를 바꾸었을 경우 다음 호출에도 바뀐 구분자를 활용하여 토큰을 분리한다.










